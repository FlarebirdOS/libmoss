# Configuration Class and Layering

Relevant source files

* [source/moss/config/io/configuration.d](../source/moss/config/io/configuration.d)

This document explains the `Configuration` class, which implements libmoss's layered configuration system. It covers how configuration files are discovered, loaded, and merged from vendor and administrator locations, and how the masking mechanism allows administrators to disable vendor-provided configurations.

For information about YAML schema validation and the `YamlSchema` UDA system, see [YAML Schema and Validation](4.2-yaml-schema-and-validation). For details about snippet implementation and configuration masking behavior, see [Configuration Snippets and Masking](4.3-configuration-snippets-and-masking).

## Purpose and Scope

The `Configuration` class is the central component of moss-config that manages hierarchical configuration loading. It discovers configuration files from multiple search paths, applies precedence rules (vendor configurations are overridden by admin configurations), and merges them into a final configuration object or collection of sections.

## Configuration Class Architecture

The `Configuration` class is defined as a generic template `Configuration(C)` where `C` represents the configuration data structure type. The class automatically determines whether to operate in array mode (for configurations with multiple sections) or flat mode (for single-object configurations) based on whether `C` is an array type.

```mermaid
classDiagram
    class Configuration {
        -SearchPath[] _paths
        -SnippetType[] _snippets
        -SnippetType[] adminSnippets
        -SnippetType[] vendorSnippets
        -ConfigurationDomain _domain
        +this(vendorPrefix)
        +load(rootPrefix)
        +snippets() : SnippetType[]
        +paths() : SearchPath[]
        +domain() : ConfigurationDomain
    }
    class SearchPath {
        +string path
        +ConfigType type
    }
    class ConfigType {
        «enumeration»
        File
        Directory
        Vendor
        Admin
    }
    class Snippet {
        +string name
        +bool enabled
        +load()
        +explicitlyDefined()
    }
    class ConfigurationDomain {
        +string domain
        +string applicationIdentity
    }
    Configuration --> SearchPath : contains
    Configuration --> Snippet : manages
    Configuration --> ConfigurationDomain : has
    SearchPath --> ConfigType : uses
```

**Sources:** [source/moss/config/io/configuration.d87-384](../source/moss/config/io/configuration.d#L87-L384)

## Configuration Path Hierarchy

The configuration system uses a two-tier hierarchy: vendor-provided defaults and administrator overrides. The search paths are constructed based on the `ConfigurationDomain` UDA attached to the configuration data structure.

| Path Type | Location Template | Purpose |
| --- | --- | --- |
| Vendor File | `{vendorPrefix}/share/{appID}/{domain}.conf` | Default configuration file |
| Vendor Directory | `{vendorPrefix}/share/{appID}/{domain}.conf.d/` | Default configuration snippets |
| Admin File | `/etc/{appID}/{domain}.conf` | System administrator overrides |
| Admin Directory | `/etc/{appID}/{domain}.conf.d/` | System administrator override snippets |

The `vendorPrefix` defaults to `"usr"`, making the full vendor path typically `/usr/share/{appID}/{domain}.conf`.

```mermaid
flowchart TD

VendorFile["Vendor File<br>/usr/share/appID/domain.conf"]
VendorDir["Vendor Directory<br>/usr/share/appID/domain.conf.d/*.conf"]
AdminFile["Admin File<br>/etc/appID/domain.conf"]
AdminDir["Admin Directory<br>/etc/appID/domain.conf.d/*.conf"]
P1["Unsupported markdown: list"]
P2["Unsupported markdown: list"]
P3["Unsupported markdown: list"]
P4["Unsupported markdown: list"]
Merge["Merged Configuration"]

VendorFile --> P1
VendorDir --> P2
AdminFile --> P3
AdminDir --> P4
P1 --> Merge
P2 --> Merge
P3 --> Merge
P4 --> Merge

subgraph subGraph1 ["Precedence Order (Low to High)"]
    P1
    P2
    P3
    P4
end

subgraph subGraph0 ["Configuration Hierarchy"]
    VendorFile
    VendorDir
    AdminFile
    AdminDir
end
```

**Sources:** [source/moss/config/io/configuration.d75-79](../source/moss/config/io/configuration.d#L75-L79) [source/moss/config/io/configuration.d102-119](../source/moss/config/io/configuration.d#L102-L119)

## Search Path Construction

The constructor builds an array of `SearchPath` structures that define where configuration files may be located. Each `SearchPath` combines a file system path with a `ConfigType` bitmask indicating whether it's a file or directory and whether it's vendor or admin controlled.

```mermaid
flowchart TD

Start["Configuration Constructor<br>this(vendorPrefix)"]
ExtractDomain["Extract @ConfigurationDomain UDA<br>from type C"]
BuildPaths["Build SearchPath array"]
VendorFilePath["SearchPath:<br>usr/share/appID/domain.conf<br>Type: File | Vendor"]
VendorDirPath["SearchPath:<br>usr/share/appID/domain.conf.d<br>Type: Directory | Vendor"]
AdminFilePath["SearchPath:<br>etc/appID/domain.conf<br>Type: File | Admin"]
AdminDirPath["SearchPath:<br>etc/appID/domain.conf.d<br>Type: Directory | Admin"]
StorePaths["Store in _paths array"]

Start --> ExtractDomain
ExtractDomain --> BuildPaths
BuildPaths --> VendorFilePath
BuildPaths --> VendorDirPath
BuildPaths --> AdminFilePath
BuildPaths --> AdminDirPath
VendorFilePath --> StorePaths
VendorDirPath --> StorePaths
AdminFilePath --> StorePaths
AdminDirPath --> StorePaths
```

The `ConfigType` enum uses bitflags to represent multiple properties simultaneously:

| Flag | Value | Meaning |
| --- | --- | --- |
| `ConfigType.File` | `1 << 0` | Path represents a file |
| `ConfigType.Directory` | `1 << 1` | Path represents a directory |
| `ConfigType.Vendor` | `1 << 2` | Path is vendor-controlled |
| `ConfigType.Admin` | `1 << 3` | Path is admin-controlled |

**Sources:** [source/moss/config/io/configuration.d92-119](../source/moss/config/io/configuration.d#L92-L119) [source/moss/config/io/configuration.d33-54](../source/moss/config/io/configuration.d#L33-L54) [source/moss/config/io/configuration.d56-60](../source/moss/config/io/configuration.d#L56-L60)

## Configuration Loading Process

The `load()` method performs the actual configuration discovery and merging. It iterates through the search paths in order, loading snippets from vendor locations first, then admin locations, allowing admin configurations to override vendor defaults.

```mermaid
sequenceDiagram
  participant Client
  participant Configuration
  participant loadConfigFile
  participant Snippet
  participant FileSystem

  Client->>Configuration: load(rootPrefix)
  loop [Masked (symlink to /dev/null)]
    Configuration->>FileSystem: Check if path exists
    FileSystem-->>Configuration: Directory exists
    Configuration->>FileSystem: dirEntries(*.conf)
    FileSystem-->>Configuration: Sorted file list
    Configuration->>loadConfigFile: loadConfigFile(path, type)
    loadConfigFile->>Snippet: new Snippet(path)
    loadConfigFile->>loadConfigFile: Check if masked
    loadConfigFile->>Configuration: Disable matching vendor snippet
    loadConfigFile->>Snippet: load()
    Snippet->>FileSystem: Read YAML
    FileSystem-->>Snippet: Configuration data
    loadConfigFile->>Configuration: Add to _snippets
    loadConfigFile->>Snippet: load()
    Snippet->>FileSystem: Read YAML
    FileSystem-->>Snippet: Configuration data
    loadConfigFile->>Configuration: Add to _snippets
    FileSystem-->>Configuration: File exists
    Configuration->>loadConfigFile: loadConfigFile(path, type)
    Configuration->>Configuration: loadSections()
    Configuration->>Configuration: loadConfiguration()
  end
  Configuration-->>Client: Configuration loaded
```

**Sources:** [source/moss/config/io/configuration.d140-186](../source/moss/config/io/configuration.d#L140-L186) [source/moss/config/io/configuration.d238-262](../source/moss/config/io/configuration.d#L238-L262)

## Directory Processing Details

When a search path represents a directory (with the `.conf.d` suffix), the loader finds all files ending in `.conf` within that directory, sorts them alphabetically, and processes them in order. This allows for predictable layering when multiple snippet files exist.

```mermaid
flowchart TD

Dir["domain.conf.d/"]
F1["10-base.conf"]
F2["20-overrides.conf"]
F3["99-local.conf"]
O1["Unsupported markdown: list"]
O2["Unsupported markdown: list"]
O3["Unsupported markdown: list"]
Result["Merged Configuration"]

Dir --> F1
Dir --> F2
Dir --> F3
F1 --> O1
F2 --> O2
F3 --> O3
O1 --> Result
O2 --> Result
O3 --> Result

subgraph subGraph1 ["Processing Order"]
    O1
    O2
    O3
end

subgraph subGraph0 ["Files Found"]
    F1
    F2
    F3
end
```

**Sources:** [source/moss/config/io/configuration.d160-169](../source/moss/config/io/configuration.d#L160-L169)

## Array vs Flat Configuration Modes

The `Configuration` class supports two operational modes determined by whether the template parameter `C` is an array type:

### Array Configuration Mode

When `C` is an array type (e.g., `RepositoryDefinition[]`), the configuration manages sections identified by an `id` field. Each section can be independently defined or overridden across multiple snippets.

```mermaid
flowchart TD

ElemType["Element Type:<br>typeof(*C.init.ptr)"]
Sections["_sections: ElemType[string]<br>Dictionary keyed by ID"]
LoadSections["loadSections()<br>Merge sections by ID"]
S1_Sec1["Section id='repo-a'<br>field1=value1"]
S1_Sec2["Section id='repo-b'<br>field1=value2"]
S2_Sec1["Section id='repo-a'<br>field2=override"]
Final1["repo-a:<br>field1=value1<br>field2=override"]
Final2["repo-b:<br>field1=value2"]

S1_Sec1 --> LoadSections
S1_Sec2 --> LoadSections
S2_Sec1 --> LoadSections
Sections --> Final1
Sections --> Final2

subgraph subGraph3 ["Final Sections"]
    Final1
    Final2
end

subgraph subGraph2 ["Snippet 2: admin override"]
    S2_Sec1
end

subgraph subGraph1 ["Snippet 1: vendor config"]
    S1_Sec1
    S1_Sec2
end

subgraph subGraph0 ["Array Mode: C is SomeType[]"]
    ElemType
    Sections
    LoadSections
    LoadSections --> Sections
end
```

The `loadSections()` method iterates through enabled snippets and merges sections with matching IDs. For each explicitly defined field in a snippet's section, it overwrites the corresponding field in the stored section.

**Sources:** [source/moss/config/io/configuration.d196-219](../source/moss/config/io/configuration.d#L196-L219) [source/moss/config/io/configuration.d271-324](../source/moss/config/io/configuration.d#L271-L324)

### Flat Configuration Mode

When `C` is not an array type, the configuration manages a single object where fields are overridden sequentially as snippets are processed.

```mermaid
flowchart TD

ConfigObj["_config: ElemType<br>Single configuration object"]
LoadConfig["loadConfiguration()<br>Override fields"]
S1["field1=default1<br>field2=default2"]
S2["field2=override2<br>field3=value3"]
Final["field1=default1<br>field2=override2<br>field3=value3"]

S1 --> LoadConfig
S2 --> LoadConfig
ConfigObj --> Final

subgraph subGraph3 ["Final Configuration"]
    Final
end

subgraph subGraph2 ["Snippet 2: admin override"]
    S2
end

subgraph subGraph1 ["Snippet 1: vendor config"]
    S1
end

subgraph subGraph0 ["Flat Mode: C is a struct"]
    ConfigObj
    LoadConfig
    LoadConfig --> ConfigObj
end
```

The `loadConfiguration()` method processes enabled snippets and for each explicitly defined field, overwrites the value in the single `_config` object.

**Sources:** [source/moss/config/io/configuration.d220-231](../source/moss/config/io/configuration.d#L220-L231) [source/moss/config/io/configuration.d327-361](../source/moss/config/io/configuration.d#L327-L361)

## Field Override Logic

The configuration system only overwrites fields that are explicitly defined in a snippet. This is determined by calling `snippet.explicitlyDefined(fieldName)` (for flat mode) or `snippet.explicitlyDefined(fieldName, sectionId)` (for array mode).

```mermaid
flowchart TD

Start["Process Snippet Field"]
CheckExplicit["snippet.explicitlyDefined(field)?"]
Override["Override field in<br>target configuration"]
Skip["Skip field<br>(keep current value)"]

Start --> CheckExplicit
CheckExplicit --> Override
CheckExplicit --> Skip
```

This logic is implemented using compile-time introspection with `FieldNameTuple` to iterate over all fields:

```
static foreach (idx, name; FieldNameTuple!ElemType)
{
    mixin("auto candidateFieldValue = candidateSection." ~ name ~ ";");
    if (snip.explicitlyDefined(name, id))
    {
        mixin("storedSection." ~ name ~ " = candidateFieldValue;");
    }
}
```

**Sources:** [source/moss/config/io/configuration.d301-312](../source/moss/config/io/configuration.d#L301-L312) [source/moss/config/io/configuration.d339-350](../source/moss/config/io/configuration.d#L339-L350)

## Configuration Masking

Admin configurations can mask (disable) vendor configurations by creating a symlink to `/dev/null` with the same name as the vendor configuration file. When the loader encounters a masked admin snippet, it disables the corresponding vendor snippet by name.

```mermaid
flowchart TD

LoadAdmin["Loading Admin Snippet"]
CheckMasked["Is path a symlink<br>to /dev/null?"]
FindVendor["Find vendor snippet<br>with same name"]
DisableVendor["Set vendor snippet<br>enabled = false"]
SkipLoad["Skip loading<br>this admin snippet"]
NormalLoad["Load admin snippet<br>normally"]

LoadAdmin --> CheckMasked
CheckMasked --> FindVendor
FindVendor --> DisableVendor
DisableVendor --> SkipLoad
CheckMasked --> NormalLoad
```

The masking check is performed in the `isMasked()` static method, which reads the symlink target and compares it to the constant `maskTarget = "/dev/null"`.

**Sources:** [source/moss/config/io/configuration.d243-254](../source/moss/config/io/configuration.d#L243-L254) [source/moss/config/io/configuration.d366-374](../source/moss/config/io/configuration.d#L366-L374) [source/moss/config/io/configuration.d29-31](../source/moss/config/io/configuration.d#L29-L31)

## Snippet Management

The `Configuration` class maintains three separate snippet collections:

| Collection | Type | Purpose |
| --- | --- | --- |
| `_snippets` | `SnippetType[]` | All loaded snippets in load order |
| `vendorSnippets` | `SnippetType[]` | Vendor-controlled snippets only |
| `adminSnippets` | `SnippetType[]` | Admin-controlled snippets only |

Separating vendor and admin snippets allows the masking mechanism to efficiently disable vendor snippets when corresponding admin masks are encountered.

```mermaid
flowchart TD

AllSnippets["_snippets<br>(all loaded snippets)"]
VendorList["vendorSnippets<br>(vendor only)"]
AdminList["adminSnippets<br>(admin only)"]
V1["vendor/domain.conf"]
V2["vendor/domain.conf.d/10.conf"]
A1["admin/domain.conf"]
A2["admin/domain.conf.d/20.conf"]

V1 --> VendorList
V1 --> AllSnippets
V2 --> VendorList
V2 --> AllSnippets
A1 --> AdminList
A1 --> AllSnippets
A2 --> AdminList
A2 --> AllSnippets

subgraph subGraph1 ["Processing Order"]
    V1
    V2
    A1
    A2
end

subgraph subGraph0 ["Snippet Collections"]
    AllSnippets
    VendorList
    AdminList
end
```

The `snippets` property returns only enabled snippets from the `_snippets` collection, filtering out any that have been masked.

**Sources:** [source/moss/config/io/configuration.d376-383](../source/moss/config/io/configuration.d#L376-L383) [source/moss/config/io/configuration.d191-194](../source/moss/config/io/configuration.d#L191-L194)

## Configuration Domain

The `ConfigurationDomain` UDA must be attached to the configuration data type `C`. It specifies two pieces of information:

* `domain`: The configuration domain name (e.g., "repos", "triggers")
* `applicationIdentity`: The application identifier (e.g., "moss")

These values are extracted via compile-time reflection and used to construct the search paths. The constructor enforces that exactly one `@ConfigurationDomain` UDA is present and that neither field is empty.

**Sources:** [source/moss/config/io/configuration.d94-100](../source/moss/config/io/configuration.d#L94-L100) [source/moss/config/io/configuration.d132-135](../source/moss/config/io/configuration.d#L132-L135)

## Public API Summary

| Method/Property | Return Type | Description |
| --- | --- | --- |
| `this(vendorPrefix)` | Constructor | Initialize with custom vendor prefix (default: "usr") |
| `load(rootPrefix)` | `void` | Load configuration from filesystem under root prefix |
| `paths` | `const(SearchPath[])` | Return configured search paths |
| `domain` | `const(ConfigurationDomain)` | Return configuration domain information |
| `snippets` | Filtered range | Return all enabled snippets |
| `ids` | Range (array mode) | Return unique section IDs across all snippets |
| `sections` | Range (array mode) | Return all merged configuration sections |
| `config` | `ElemType` (flat mode) | Return merged configuration object |

**Sources:** [source/moss/config/io/configuration.d87-384](../source/moss/config/io/configuration.d#L87-L384)